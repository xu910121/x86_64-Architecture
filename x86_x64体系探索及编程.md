# x86_x64体系探索及编程

### 二进制数的排序：

**MSB和LSB**：

在日常的书写表达上，最左边的位是最高位。数的位排列从左到右，对应的值从高到低。在机器的数字电路上，数的高低位可以从左到右进行排列，也可以从右到左进行排列。

以一个自然的二进制表达序列上32位的二进制数为例，最右边是bit 0,最左边是bit 31,。那么bit 0就用LSB（Least Significant Bit，最低有效位）来表示，bit 31就用MSB（Most Significant Bit，最高有效位）来表示。

![Screenshot from 2018-12-20 16-34-44](X:\Screenshot from 2018-12-20 16-34-44.png)

**系统段寄存器**：GDTR，LDTR，IDTR（中断描述符表寄存器），以及TR（任务寄存器）。使用在系统编程里，是保护模式编程里重要的系统数据资源。

**系统段寄存器操作数是隐式提供的，没有明确的字面助记符**

LGDT [GTD_BASE]	;从内存[GTD_BASE]处加载GDT的base和limit值到GDTR，隐式提供目的操作数为GDTR。

x86体系中还有更多隐式寄存器，MSR（Model Specific Register）能提供对处理器更多的配置和管理。每个MSR寄存器有相应的编址。在ecx寄存器里放入 MSR的地址，由rdmsr指令进行读取，wdmsr指令进行写。

​	mov ecx, 1bh ;	APIC_BASE寄存器地址

​	rdmsr		；	读入APIC_BASE寄存器的64位值到eda:eax

​	mov ecx, c0000080h ; EFER地址

​	rdmsr		；	读入EFER原值

​	bts eax, 8	; EFER.LME = 1

​	wdmsr		; 	开启long mode



**I/O端口寻址**

​	x86/64体系实现了独立的64K I/O地址空间（从0000H到FFFFH），IN和OUT指令用来访问这个I/O地址。

​	in指令读取外部端口数据，out指令往外部端口写数据。<u>（<!--何为外部端口？I/O端口？-->）</u>

​		in al, 20H	;	从端口20H里读取一个byte

​	in和out指令是CPU和外部接口进行通信的工具。许多设备的底层驱动还是要靠in/out指令。端口的寻址是通过immediate形式，还可以通过DX寄存器提供port值。immediate只能提供8位的port值，在x86上提供了64K范围的port，访问0xff以上的port必须使用DX寄存器提供。

​	在x86/64体系中device（设备）还可以使用memory I/O（I/O内存映射）方式映射到物理地址空间，典型的如VGA设备的buffer被映射到物理地址中。



**cpuid**

​	从486处理器开始，加入cpuid指令。eflags寄存器的bit 21是ID（Processor Feature Identification）标志位。修改eflags寄存器的bit 21标志位，如果能修改成功，就表示支持cpuid指令。

leaf（叶）

​	功能号使用leaf术语，例如：CPUID的01号功能，你可以称其为CPUID的01 leaf（叶）。

sub-leaf（子叶）

​	对于一些较复杂的信息查询，往往需要一个辅助的子号。EAX寄存器输入的是main leaf，ECX寄存器提供的是sub-leaf。

​		mov eax, 0Bh; 		//main leaf

​		mov ecx, 0;			//sub-leaf

​		cpuid

​	如上所示，0B号功能就是main leaf，ECX提供的0号就是sub-leaf。

CPUID指令的描述形式

​	当软件需要判断某项功能处理器是否支持时，使用CPUID指令进行查询，在Intel手册中使用了下面的描述形式。

​					![1546075298191](C:\Users\xu910\AppData\Roaming\Typora\typora-user-images\1546075298191.png)

​	上面是判断处理器是否支持PAE（Physical Address Extensions）功能时的描述，当CPUID.01H:EDX[6]的值为1时，表示支持PAE功能。

基本信息与扩展信息

​	从CPUID指令获得的信息有两大类：base和extended，要获得信息必须要先提供相应的leaf，每一类信息都有最大的功能号限制。

​	某些功能号下面还有许多sub-leaf，也就是信息的子集。使用CPUID指令之前在eax寄存器提供需要查询的某个信息相应的功能号。

​		mov eax， 0			//功能号0

​		cpuid

​	返回的相应信息放在eax、ebx、ecx、edx寄存器中。这些信息是32位的，因此在64位模式下，rax、rbx、rcx、rdx寄存器的高32位被清0。

查询最大的leaf号

​	CPUID指令被使用来查询处理器所支持的特性，因此在使用CPUID所支持的leaf数量是与处理器相关的。很多时候，在使用某个leaf之前，必须判断处理器是否支持该leaf。

基本最大功能号

​	使用CPUID的00Hleaf来查询，最大的基本功能号返回在EAX寄存器里。

​		mov eax，0  	//功能号0

​		cpuid		

​		cmp eax，0BH   //判断是否支持0B leaf

​		jb  no_support //假如不支持。

扩展最大功能号

​	最大扩展功能号也可以查询。

​		mov eax，80000000 //功能号80000000（main leaf）

​		cpuid				//查询最大扩展功能号

​		cmp eax， 80000001H   //判断是否支持8000001H leaf

​	**如果在eax中输入的功能号超过了最大的功能号，那么将返回basic最大功能号的信息。**

​	**当输入的功能号<=最大功能号时，如果CPU并不支持该功能号，则所有寄存器返回0值，eax=ebx=ecx=edx=0。**

处理器扩展状态信息

​	0Dh功能号是获得处理器对Processor Extended State（处理器扩展状态）的支持度，这在AVX指令编程里非常重要。

​	0Dh功能号是一个功能集，在前面的例子中：

​		mov eax，0Dh ；		//0Dh功能号

​		mov ecx，0	；		//main leaf功能

​		cpuid；				//得到0Dh的main leaf功能

​	这个main leaf功能就可以获得CPU目前对处理器状态的支持度。eax和edx寄存器返回processor extended state的enable/disable位图。

![1546090879863](C:\Users\xu910\AppData\Roaming\Typora\typora-user-images\1546090879863.png)

​	这个Processor Extended State值将影响到XCR0（Extended Control Register）的值。当State值得某位为0时，那么XCR0相应的位为保留位（此位不能被XSETBV指令设置）。



**Eflags**

​	在eflags寄存器里可以分为status flags（状态标志位）、control flags（控制标志位）和system flags（系统标志位）

​	control flags只有一个DF（Direction Flags）标志位（bit10），它使用在LODSx，STOSx，MOVSx，SCASx，OUTSx，以及INSx这类串指令，指示串指令的指针方向。

​	DF标志所表达的意思是（以movsb指令为例）在一个循环里：

​	`if (eflags.DF == 0)`

`​	{`

`​		buffer[edi++] == source[esi++]		/* 指针edi和esi都是递增 */`

`​	}else if (eflags.DF == 1)`

`​	{`

`​		buffer[edi--] = source[esi--]		/* 指针edi和esi都是递减 */`

`​	}`

​	在递增情况下，源串和目标串指针应该指向起始点；在递减的情况下，源串和目标串指针应该执行终点。这是软件设计者的职责。

*Eflags中的状态标志位*

​	status flags包括：OF（溢出标志），SF（符号位标志），ZF（零标志），AF（调整位标志），CF（进位标志），以及PF（奇偶位标志）。这些标志位反映了指令执行结果的状态值。

*PF标志*

​	指令判断结果值得最低字节（byte 0），而设置相应的PF标志位，如下所示：

​			1100 0001 <u>1010 0011</u> 		//最低字节1的数量是偶数，则eflags.DF = 1

*AF标志*

​	当运算时bit 3发生向上进位或借位是，AF标志被设置。AF标志位使用在BCD码的运算指令上，如下面使用AF标志位的例子。

​		mov al，8			；al = 0000 1000B

​		mov bl，9			;   bl = 0000 1001B

​		add al，bl			；al = 0001 0001B，AF标志为1

​		aaa					；使用AF标志进行调整，AX的结果是：00000001 00000111B

​	在上面的8+9式子里，bit 3向bit 4进1位。AAA指令根据AF标志进行调整后，AX的值变成0107H（BCD码形式）

*signed数的运算*

​	status flags中ZF标志位可以用在signed和unsigned数上。

​	signed数运算中使用的标志位有：OF（溢出）标志和SF（符号）标志。

​	对于signed数溢出，有两种情况：

​	① overflow（向上溢出）：当结果值超出signed数的最大值时产生overflow

​	② underflow（向下溢出）：当结果值超出signed数的最小值时产生underflow。

​	当结果产生overflow或者underflow时会对OF标志位置位。

​	**两个正数相加，结果为负数时，产生了overflow溢出。**

​	**两个负数相加，结果为正数，产生了underflow溢出**。

​	**正数和负数相加，不会产生溢出。**

***signed数的比较操作***

​	OF、SF以及ZF标志都用于signed数的比较。在执行cmp指令比较时，是对两个数进行相减操作，将比较的结果反映在标志位上。

​	**当OF == SF时，比较结果是大于。**

​	**当OF <> SF 时，比较结果是小于。**

***signed数的条件码***

​	基于SF标志、OF标志，以及ZF标志位，下面是用于signed数的条件码。

​		G（greater）		；OF == SF，并且 ZF = 0

​		L（less）		；OF <> SF

​		GE（greater or equal）	； OF == SF

​		LE（less or equal）		；OF <> SF 或者 ZF = 1

​	在GE（大于等于）的情况下只需判断OF是否等于SF标志，无论ZF是否为零都满足条件。而在L（小于）的情况下只需判断OF不等于SF标志就可以了，也不需要判断ZF标志。

***unsigned数的运算***

​	ZF标志和CF标志被用在与unsigned数相关运算里，在unsigned数的相关比较中不会使用OF和SF这两个标志位。

​	在相加运算中，由于向前进位而使用CF标志置位。在相减运算中，由于向前借位也会使CF标志置位。

***unsigned数的比较及条件码***

​	当unsigned数相减时，如果不够减则会产生借位（eflags.CF=1）,表明是小于关系。

​		A（Above）					；CF = 0并且ZF = 0

​		B（Below）					；CF = 1

​		AE（Above or equal）			；CF = 0

​		BE（Below or equal）			；CF = 1或者ZF = 1

​	AE和B的比较中都无需判断ZF标志。

***IOPL标志位***

​	eflags有两个位来表示IOPL（I/O Privilege Level）标志位，**指示访问I/O地址空间所需要的权限**，这个值仅在CPL=0权限下可以修改。IOPL标志还将影响到IF标志位，IF标志位在具有IOPL所规定的权限内能被修改。

​	只有当CPL=0时，可以改变IOPL的值，当CPL<=IOPL时，可以改变IF标志位。

​	改变IOPL值可以使用popfd指令和iret指令，IF标志位还有专门的指令开/关中断：sti和cli指令。当使用popfd指令进行修改时，没有足够的权限时不能修改其值，但是并不会产生异常。

​	修改过程大致：

​		pushfd			；get eflags

​		or DWORD [esp], 0x3000		;将IOPL = 3

​		popfd						；modify the IOPL

***I/O Bitmap***

​	~~IOPL控制着程序的I/O地址空间访问权，只有在足够的权限下才能访问I/O地址，否则会产生#GP异常。这句话说的不太完整，还与I/O位图有关。~~

​	如果当前CPL>IOPL（值大于），在TSS段中的I/O Bitmap有最后的决定权。

​	即使当前运行的权限低于IOPL所规定的权限，也可以在TSS中的I/O Bitmap对某些port进行设置，达到可以访问I/O地址空间。当CPL>IOPL时，对port的I/O访问处理器将检查I/O Bitmap中相应的port位以决定这个I/O访问是否违例，当CPL<=IOPL时则无需检查I/O Bitmap（CPL数值越小，则权限越大）。

​	I/O Bitmap中的每个bit对应于一个port，当这个bit被置位时（设置为1），程序对port无访问权限。当这个bit被清0时，port是可以访问的。

***TF标志与RF标志***

​	显然eflags.RF标志与eflags.TF标志是配合一起使用的，放TF标志被置位时，就代表开启了single-debug（单步调试）功能，处理器 将进入single-debug状态。

​	当TF标志被置位，执行下一条指令后，处理器进入#DB处理。这是因为single-debug属于trap类型的#DB异常。

​	实例：

​		；开启single debug功能

​			`pushfd`

​			`bts dword [esp], 8				;eflags.TF=1`

​			`popfd					;更新eflags寄存器`

​			`mov eax，1					；test 1`

​			`mov eax，2					；test 2`

​			`mov eax，3					；test 3`

​			`mov eax，4					；test 4`

​			`mov eax，5					；test 5`

​	popfd指令执行完后，将更新TF标志为1，那么应该是在test 1之前还是之后产生#DB异常？答案是在test 1之后（test 2）之前，是在TF被置位后的下一条指令执行完成后产生#DB异常。

​	**处理器在进入#DB异常处理程序之前，会将TF标志清0以防止在中断处理程序内发生single-debug**，这是显而易见的事情，RF标志也会被清0。在进入中断处理程序前，NT和VM标志都会得到清0。

​	那么，在压入单步调试#DB处理程序stack内的eflags寄存器中TF是原来的值（即为1），RF标志被清0。<!--此处应该区分清被调试程序的栈和中断处理程序的栈，在中断处理程序中，eflags的TF标志位肯定要为0，因为为1时，中断处理程序也要进行single debug模式，这肯定不是我们想要的，但是中断处理程序的栈中eflags.TF为1,是因为中断处理程序返回时弹出eflags，回到被调试的程序时，被调试的程序eflags.TF应该为1。-->

![1546419872909](E:\study\x86_64-Architecture\assets\1546419872909.png)



























































​	

​	