# x86_x64体系探索及编程

### 二进制数的排序：

**MSB和LSB**：

在日常的书写表达上，最左边的位是最高位。数的位排列从左到右，对应的值从高到低。在机器的数字电路上，数的高低位可以从左到右进行排列，也可以从右到左进行排列。

以一个自然的二进制表达序列上32位的二进制数为例，最右边是bit 0,最左边是bit 31,。那么bit 0就用LSB（Least Significant Bit，最低有效位）来表示，bit 31就用MSB（Most Significant Bit，最高有效位）来表示。

![Screenshot from 2018-12-20 16-34-44](X:\Screenshot from 2018-12-20 16-34-44.png)

**系统段寄存器**：GDTR，LDTR，IDTR（中断描述符表寄存器），以及TR（任务寄存器）。使用在系统编程里，是保护模式编程里重要的系统数据资源。

**系统段寄存器操作数是隐式提供的，没有明确的字面助记符**

LGDT [GTD_BASE]	;从内存[GTD_BASE]处加载GDT的base和limit值到GDTR，隐式提供目的操作数为GDTR。

x86体系中还有更多隐式寄存器，MSR（Model Specific Register）能提供对处理器更多的配置和管理。每个MSR寄存器有相应的编址。在ecx寄存器里放入 MSR的地址，由rdmsr指令进行读取，wdmsr指令进行写。

​	mov ecx, 1bh ;	APIC_BASE寄存器地址

​	rdmsr		；	读入APIC_BASE寄存器的64位值到eda:eax

​	mov ecx, c0000080h ; EFER地址

​	rdmsr		；	读入EFER原值

​	bts eax, 8	; EFER.LME = 1

​	wdmsr		; 	开启long mode



**I/O端口寻址**

​	x86/64体系实现了独立的64K I/O地址空间（从0000H到FFFFH），IN和OUT指令用来访问这个I/O地址。

​	in指令读取外部端口数据，out指令往外部端口写数据。<u>（<!--何为外部端口？I/O端口？-->）</u>

​		in al, 20H	;	从端口20H里读取一个byte

​	in和out指令是CPU和外部接口进行通信的工具。许多设备的底层驱动还是要靠in/out指令。端口的寻址是通过immediate形式，还可以通过DX寄存器提供port值。immediate只能提供8位的port值，在x86上提供了64K范围的port，访问0xff以上的port必须使用DX寄存器提供。

​	在x86/64体系中device（设备）还可以使用memory I/O（I/O内存映射）方式映射到物理地址空间，典型的如VGA设备的buffer被映射到物理地址中。



**cpuid**

​	从486处理器开始，加入cpuid指令。eflags寄存器的bit 21是ID（Processor Feature Identification）标志位。修改eflags寄存器的bit 21标志位，如果能修改成功，就表示支持cpuid指令。

leaf（叶）

​	功能号使用leaf术语，例如：CPUID的01号功能，你可以称其为CPUID的01 leaf（叶）。

sub-leaf（子叶）

​	对于一些较复杂的信息查询，往往需要一个辅助的子号。EAX寄存器输入的是main leaf，ECX寄存器提供的是sub-leaf。

​		mov eax, 0Bh; 		//main leaf

​		mov ecx, 0;			//sub-leaf

​		cpuid

​	如上所示，0B号功能就是main leaf，ECX提供的0号就是sub-leaf。

CPUID指令的描述形式

​	当软件需要判断某项功能处理器是否支持时，使用CPUID指令进行查询，在Intel手册中使用了下面的描述形式。

​					![1546075298191](C:\Users\xu910\AppData\Roaming\Typora\typora-user-images\1546075298191.png)

​	上面是判断处理器是否支持PAE（Physical Address Extensions）功能时的描述，当CPUID.01H:EDX[6]的值为1时，表示支持PAE功能。

基本信息与扩展信息

​	从CPUID指令获得的信息有两大类：base和extended，要获得信息必须要先提供相应的leaf，每一类信息都有最大的功能号限制。

​	某些功能号下面还有许多sub-leaf，也就是信息的子集。使用CPUID指令之前在eax寄存器提供需要查询的某个信息相应的功能号。

​		mov eax， 0			//功能号0

​		cpuid

​	返回的相应信息放在eax、ebx、ecx、edx寄存器中。这些信息是32位的，因此在64位模式下，rax、rbx、rcx、rdx寄存器的高32位被清0。

查询最大的leaf号

​	CPUID指令被使用来查询处理器所支持的特性，因此在使用CPUID所支持的leaf数量是与处理器相关的。很多时候，在使用某个leaf之前，必须判断处理器是否支持该leaf。

基本最大功能号

​	使用CPUID的00Hleaf来查询，最大的基本功能号返回在EAX寄存器里。

​		mov eax，0  	//功能号0

​		cpuid		

​		cmp eax，0BH   //判断是否支持0B leaf

​		jb  no_support //假如不支持。

扩展最大功能号

​	最大扩展功能号也可以查询。

​		mov eax，80000000 //功能号80000000（main leaf）

​		cpuid				//查询最大扩展功能号

​		cmp eax， 80000001H   //判断是否支持8000001H leaf

​	**如果在eax中输入的功能号超过了最大的功能号，那么将返回basic最大功能号的信息。**

​	**当输入的功能号<=最大功能号时，如果CPU并不支持该功能号，则所有寄存器返回0值，eax=ebx=ecx=edx=0。**

处理器扩展状态信息

​	0Dh功能号是获得处理器对Processor Extended State（处理器扩展状态）的支持度，这在AVX指令编程里非常重要。

​	0Dh功能号是一个功能集，在前面的例子中：

​		mov eax，0Dh ；		//0Dh功能号

​		mov ecx，0	；		//main leaf功能

​		cpuid；				//得到0Dh的main leaf功能

​	这个main leaf功能就可以获得CPU目前对处理器状态的支持度。eax和edx寄存器返回processor extended state的enable/disable位图。

![1546090879863](C:\Users\xu910\AppData\Roaming\Typora\typora-user-images\1546090879863.png)

​	这个Processor Extended State值将影响到XCR0（Extended Control Register）的值。当State值得某位为0时，那么XCR0相应的位为保留位（此位不能被XSETBV指令设置）。